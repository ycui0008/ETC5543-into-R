---
title: "5543 Report - ggplotIntro"
author: "Yuheng Cui"
date: "10/16/2021"
output: 
  bookdown::pdf_document2:
    number_sections: true
    fig_caption: true
    toc: yes
    toc_depth: 2
bibliography: references.bib
csl: norsk-apa-manual.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE,
                      warning = FALSE,
                      fig.align = "center")
```

# Introduction

This report will introduce R package `ggplotIntro` and how I develop the package. I choose R for three main reasons: first, R is free and open-sourced; second, people can do basic analyses without advanced coding or programming knowledges; third, also the most important point, R has hundreds of packages. The `ggplot2` package is a very useful and basic package. @myint2020comparison suggests that basic R and `ggplot2` can make plots rated similarly on many characteristics, but "... ggplot2 graphics were generally perceived by students to be slightly more clearer overall with respect to presentation of a scientific relationship". `ggplot2` is so representative because it shows how R can draw plots and it always the first package when a person starts learning R. If a new learner knows how to use `ggplot2` package, the person can do basic data plotting and analysis. `ggplotIntro` Package is mainly used for new `ggplot2` package learner. Targeted group is new R learner. New R learners are defined as people who never used R before and have little knowledge about programming. I understand the difficulties for new learners because I learned accounting for my bachelor degree and I still remember how I struggled when I started learning R -- those lines of code look like puzzles to me. For anyone who wants to learn programming languages, not only R, two most important characteristics are self-motivation and self-learning. Because R is open-sourced, there are many websites can teach how to learn R, such as *stackoverflow* and *RStudio Community*. For most of problems and issues, we can find answers by googling. But I know a realistic issue for most new learners -- learning programming, especially at beginning, it's boring and difficult. For myself, at beginning, I always copy and paste sample code and make minor changes to see how output changes. It takes me a while to understand how to read documentation of packages and functions. Most of university students do not have problems about self-learning, but self-motivation could be an issue. As I said, programming is boring at beginning, so new learners need motivation. Motivation can be internal or external. My project is aiming to provide **external motivation**.

## Context of the project

Due to COVID-19, there is no companies needs interns now. First time I get in touch with my supervisor was in week 7. In first two meetings, we just have brief talk about the project and I drew a simple design sheet about the project. So, I started to work on the project since week 8. 

# Design of the shiny app and how to use it

## Gamification

The `ggplotIntro` should be interesting and help new learner cultivate interests in R. Interest was recognised as an independent factor and a desired outcome in the process of learning [@schiefele1991interest]. @lepper1988motivational proposed four general ways to increase intrinsic motivation, two out of four could be satisfied through gamification -- promoting students' sense of control and providing challenging activities. In the shiny app, `shinyAce` editor provide similar environment as R studio, and the difficulty levels are increasing across sections.

So, I studied how to make learning progress interesting. My supervisor and I both agreed that gamifying learning progress could be a good option. Educational games have been successfully used to teach a number of school subjects [@corbett2001cognitive]. When a person receives positive feedback from learning/gaming, he/she is likely to be motivated and wants to learn/play more. The game versions of scoreboard were much more enjoyable the normal version, and were more acceptable [@flatla2011calibration] So, the project must have a score system. A pop-up window will send a congratulatory message when the user gives correct answer or send a message containing comforting words and tips on solving questions.Pop-up window is feedback when learners submitting their answers, and the aim of pop-up windows is making people feel more ownership and purpose when engaging with tasks [@pavlus2010game]. I believe a learner will be confident when he/she got high scores in exercises. 

## Why choosing shiny app

At first, my plan was to build a package like `learnr` -- use `shiny_prerendered` Rmd file to make exercises. The advantage of this plan is good example and template already existed. I can do my project by following the template. But I prefer to use shiny app because I want to make the project more interactive and more like games. Gamification is very important in my project, because I want to show new learners that make plots through R is interesting, funny and easy. If this project just asks people doing exercises, in conventional way, the project will be just like most online tutorials.

## Why designing in this way

### First tab in the shiny app

Figure \@ref(fig:p1) is an overview of my project. Left hand side is the list of contents, and right hand side is the content. The list of contents is in this order because I believe it is a common process when people draw plots. In other words, when people get access to a data set and want to draw plots for analysis, first thing first is understanding the data – such as, dimension, variable types, and missing values of the data. I introduce how to use `?` to read documentation of data sets built inside the packages. And use `summary()` to have an overview of the data set. This is the basis of data analysis and very crucial because it is unlikely to draw good plots if you know nothing about the data. I also take screenshots of `mtcars` documentation and summary as examples in first tab.

```{r p1, fig.cap="Section 1 screenshot", out.width = '100%'}
knitr::include_graphics("screenshot/section 1.png")
```

### Second tab in the shiny app

In second tab, I let learners play around with the code. Learners can change variables and plot types and see how the code and the plot change when they select different variables and plot types. I use `mtcars` as illustration example because it is a small data set with all numeric variables. One goal of this tab is to tell learners that it is not very hard to use `ggplot2` package to draw plots, and coding is very understandable and organised stuff. At the end of second tab, I paste a link to `ggplot2` website. On the website, more `geom_` functions are introduced. I do not want to send too much contents to new learners because this shiny app is just a start point of learning R. Another goal of second tab is to show basic `ggplot2` code to learners. Knowing the basic code is enough to draw the plot. And this leads learners to third tab of the shiny app.

```{r p2, fig.cap="Section 2 screenshot", out.width = '100%'}
knitr::include_graphics("screenshot/section 2.png")
```

### Third tab in the shiny app

In third tab, I make up three very easy questions for learners. If learners read the first two tabs, they can complete all three questions in five minutes. The screenshot below shows the tab layout. The questions are all designed as fill-in-blanks style (Figure \@ref(fig:p3)). I believe this style of questions is the most acceptable questions for new learners. There are three reasons. First, this kind of questions is easy and won’t take too much time. Because this project focuses on beginner, it is not reasonable to make it very long and hard. If exercises are long, users would bother to try them; and if exercises are hard, it would make beginners lose confidence. Second, fill-in-blank questions are easier for me to make comparison to the solution. I will discuss this point later in the \@ref(Comparision) section . Third, fill-in-blanks questions can help new learners form a good coding style. When lines of code are extraordinarily long, good coding style and necessary comments are crucial. For writer him- or her- self, good coding style can make debug and review more easily. It is common that when we try to review our work which is done a few years or several months ago, we even don’t understand what we were doing at that time. So, good coding style and comments can help us remember. For other people who want to read the code, good coding style can make the code more readable. @spinellis2003reading mentioned “… programming usually is a team-based activity, and writing code that others can easily decipher has become a necessity.” So, good coding style can also ensure other team members to continue your works. 

```{r p3, fig.cap="Section 3 - Question 3 screenshot", out.width = '100%'}
knitr::include_graphics("screenshot/section 3 Q3.png")
```

After complete the question, learners can click **Submit** button to see whether they are correct (Figure \@ref(fig:p3)). If they are wrong, pop-up window will be like Figure \@ref(fig:p4). It may contain a hint message. The hint message can guide learners to solve the question. When your answer is wrong, there will be no score added in the tab.

```{r p4, fig.cap="When answer is wrong, pop-up window will be like this", out.width = '100%'}
knitr::include_graphics("screenshot/wrong 1.png")
```

If they are correct, the pop-up window will be like Figure \@ref(fig:p5). And when the question is correctly answered, one score will be added.

```{r p5, fig.cap="When answer is correct, pop-up window will be like this", out.width = '100%'}
knitr::include_graphics("screenshot/success.png")
```

Users can use the **Solution** button to see the solution to the question (Figure \@ref(fig:p6)).

```{r p6, fig.cap="Solution", out.width = '100%'}
knitr::include_graphics("screenshot/solution sample.png")
```

And users can click the below-the-folder button to check how many questions that they correctly answer in the section. Users will have two different pop-up dialog: upper window in Figure \@ref(fig:p7) will appear when users do not answer all questions correctly, lower window in Figure \@ref(fig:p7) will appear is when all questions are solved correctly. 

```{r p7, fig.cap="Score system will show two types of outcome", out.width = '100%'}
knitr::include_graphics("screenshot/tot score.png")
```


In this section, I use `diamonds` data set, because `diamonds` data set contains numeric and categorical variables. It is difficult to find a basic data set contains both types of variables. But `diamonds` has a huge disadvantage – it has `r nrow(ggplot2::diamonds)` observations. If I use all `diamonds` observations to make plot, it will take one minute to render the plot. So, I use `head()` to extract first 1000 rows in `diamonds` to reduce the time. The code chunk below is what I did for Q2. I think `head()` is reasonable because the goal of the project is not analysing data but helping new learners understand and get familiar with code.


```
ggplot(data = head(diamonds,1000), aes(x = ___, y = ___)) +
    geom_point()
```

In Q3, I talk a little about the weakness of scatterplots. And after that, I briefly introduce `geom_jitter()` and `geom_boxplot()`. In this project, I try my best to prevent overwhelming new learners. But `geom_jitter()` and `geom_boxplot()` are commonly used in practice, so, I insist introducing them.


### Fourth tab in the shiny app

In fourth section, I introduce how to use colours and shapes in data visualisation. @stone2006choosing suggests colour can enhance and clarify a presentation. 2D plots are more understandable than 3D plots. Colour and/or shape will be additional dimension(s) in the plot. In this section, I mainly introduce **colour**. Colour is more commonly used than shape in data visualisation. People’s eyes cannot detect the differences if there are more than four types of shapes in a plot. Colour can represent categorical variables, low to high numeric values, and diverging values. Colour can also represent variables with many levels. However, how to effectively use colour in data visualisation is a big topic, I can only introduce the basis of colour in data visualisation. At the end of introduction part, I use `mtcars` as example to show learners how useful colour is in data visualisation (Figure \@ref(fig:p8)).


```{r p8, fig.cap="Section 4 screenshot", out.width = '100%'}
knitr::include_graphics("screenshot/colourful mtcars.png")
```


After introduction of colour and shapes, I give two simple exercises. I make Q4 and Q5 in order to differentiate `colour` and `fill` argument in ggplot. I use `mtcars` in Q4 while using `txhousing` in Q5. I introduce bar chart in Q5. There are too many plot types, thus, I must choose some most frequently used types. Based on my personal experience, `geom_point()`, `geom_line()` and `geom_bar()` are top-3 commonly used geom in ggplot. Q4 and Q5 tells learners that `colour` should be used in scatter plot while `fill` should be used in bar plot. If `colour` is used in Q5, the pop-up window will tell him/her `fill` should be used here (Figure \@ref(fig:p9)). 

```{r p9, fig.cap="The pop-up window for Q4", out.width = '100%'}
knitr::include_graphics("screenshot/wrong 2.png")
```


### Fifth tab in the shiny app

In fifth section, I introduce how to make labels in graphs. In previous section, I introduce how to make basic plots; and when a raw plot is done, plot makers should label the plot, including x- and y-axis names and units, plot title, the data source (if applicable), and legend title (if applicable). Without proper labels, plot itself will be less readable and understandable. For example, length can be measured in many different units, such as meter, inch, kilometer, etc.. And in previous section, in `mtcars`, **cyl** and **hp** are x- and y-axis, respectively. They are meaningless for readers because they have little knowledge about the data set. We must use the full name of the variables with their units to represent coordinates. So, I make one question in this section (code shown below). There is only one question because I think labelling is easy.




```
ggplot(mtcars, aes(x = cyl, y = hp)) +
  geom_point() +
  ___(___ = "Relationship between Gross horsepower and Number of Cylinders for 32 automobiles in 1974",
       ___ = "Number of Cylinders",
       ___ = "Gross horsepower")

```

### Final tab in the shiny app

The final section is harder than previous sections – I introduce Polygon. I struggle for a while because I am not sure whether I should introduce Polygon to new learners. When I learned Polygon, I thought it was difficult. But Polygon is a simple way to draw maps, and mapping is an important part in data visualisation – John Snow’s cholera map (Figure \@ref(fig:p10)) is well-known in data visualisation history. And personally, I like mapping in data visualisation.

```{r p10, fig.cap="John Snow{{’}}s cholera map", out.width = '100%'}
knitr::include_graphics("screenshot/j snow.png")
```

In this section, I introduce two steps of drawing a map (Figure \@ref(fig:p11)). First step is “get map data” and second step is “draw the map”. Here, I introduce the simplest way to get map data. And in both steps, I give comments to help learners understand the code. 

```{r p11, fig.cap="Section 6 - Introduction", out.width = '100%'}
knitr::include_graphics("screenshot/section 6 intro.png")
```

I also use `geom_point()` to draw the map. The aim is to show why we should use Polygon (Figure \@ref(fig:p12)).

```{r p12, fig.cap="Section 6 - comparing scatter plot to polygon", out.width = '100%'}
knitr::include_graphics("screenshot/section 6 scatterplot.png")
```

Next, I use `who_covid` data set and draw map for it. `who_covid`  (Figure \@ref(fig:p13)) is a data set of `ggplotIntro` package, data wrangling part will not appear in the formal shiny app within the package. `who_covid` data is downloaded from **WHO** website.


```{r p13, fig.cap="Section 6 - who covid data set", out.width = '100%'}
knitr::include_graphics("screenshot/who_covid eg.png")
```


Figure \@ref(fig:p14) shows three steps of mapping. First step is to rename two countries to make two data sets can be merged. Second step is to merge `who_covid` and map data. Third step is to use `geom_polygon()` to draw the map.

```{r p14, fig.cap="Section 6 - who covid example", out.width = '100%'}
knitr::include_graphics("screenshot/who_covid eg2.png")
```

In this section, there are two questions – Q7 and Q8. Q7 (Figure \@ref(fig:p15)) is easy – it is almost same to the example above, except *deaths_cumulative_total* being used. Q7 is just warm up. When people first learn Polygon, they may confuse about the arguments within aes, such as, group, fill, longitude and latitude. So, I intentionally make this simple question.



```{r p15, fig.cap="Section 6 - Q7", out.width = '100%'}
knitr::include_graphics("screenshot/section 6 q7.png")
```



Q8 (Figure \@ref(fig:p16)) is little bit harder than Q7, because learners must fill in all blanks. I use a new data set here. `GDP` data is downloaded from **World Bank** website. Data wrangling is difficult for new learners, so I do all data wrangling part and merge it with map data. The merged data is called `GDP_clean`. If Q8 is answered wrongfully, hint message will pop up (Figure \@ref(fig:p17)).



```{r p16, fig.cap="Section 6 - Q8", out.width = '100%'}
knitr::include_graphics("screenshot/section 6 q8.png")
```

```{r p17, fig.cap="Section 6 - Hints for Q8", out.width = '100%'}
knitr::include_graphics("screenshot/q8 hint.png")
```



### About pipe operator (`%>%`)

In early version of shiny app, I frequently used pipe operator. In third meeting with Emi (my supervisor), she told me I should try to avoid using pipe operator, because it could be confusing to new learners. This remind me when I started learning R, I was also confused about pipe operator. So, I took her advice, and remove most of the pipe operators in the shiny app. However, in last two sections, in data wrangling part, the code would be too complex if not using pipe operators. But I think data wrangling part is not the main focus of the project, and I give enough comments in those parts by commenting after the lines of code. 

### Happen coincidence

I don’t want learners click the **Solution** button before at least trying the exercises. The aim of **Solution** button is to give learners some hints when they feel the exercises are too hard. In fact, in the shiny app, users cannot see the solutions before clicking **Submit** button. As the screenshot below showing, the **Solution** will keep loading and show nothing (Figure \@ref(fig:p18)). I tried and waited for over two minutes, but it was still loading. 

```{r p18, fig.cap="Loading Solution", out.width = '100%'}
knitr::include_graphics("screenshot/solution loading.png")
```


After clicking **Submit** button, the solution will appear (as screenshot shown below)(Figure \@ref(fig:p19)). I do not truly understand why this happens. I guess it may be sequential order between **Submit** and **Solution** buttons. That is, the content in **Solution** can be rendered only when users click **Submit** first.

```{r p19, fig.cap="Solution output", out.width = '100%'}
knitr::include_graphics("screenshot/solution output.png")
```


# Challenges

## Text display issue

The first issue I met is part of the text in the shiny app does not display in right way. Two screenshots depict the issue. After I maximising the window of the shiny app, some paragraphs would be dislocated (Figure \@ref(fig:p20) and Figure \@ref(fig:p21)). Later, I found the reason is the issue of the column width in the shiny app – when I write too much text in shiny app, the text will find a way to fill the full column width.

At first, I tried to set specific column width for each paragraph, but it did not work. Thanks for Mitch’s advice, I used `includeMd` and `includeHTML` to solve the problem. I learned that it is better not to include too much text in a shiny app. Too much text will make the shiny app unnecessarily long, and it is difficult to design pretty layout in the shiny app. For instance, in my shiny app, I include many screenshots and plots. I must create ui and sever to show those screenshots or plots. So, my workload increases and later if there are too much plots the loading speed of the shiny app will be slow. But if I use Md file or HTML file (generated by Rmd file), I can easily make the layout and draw plots. In addition, because HTML files are prerendered, reading HTML files is faster than generating plots in the shiny app. Also, `includeHTML` is just one line of code, it saves spaces and shortens the length of the shiny app.

```{r p20, fig.cap="Text display - normal", out.width = '100%'}
knitr::include_graphics("screenshot/text issue 1.png")
```

```{r p21, fig.cap="Text display - when maximising window ", out.width = '100%'}
knitr::include_graphics("screenshot/text issue 1.png")
```





## Comparison to the solutions {#Comparision}

First, I tried to follow the structure of `dwexercise` package. But there are big difference between *shiny-prerendered Rmd file* and *shiny app*. If using *shiny-prerendered Rmd file*, with `learnr` package, it is very easy to create code chunks letting users fill the answers. If using  shiny app, the structure will be totally different, because *shiny-prerendered Rmd file* supports users to run code while *ui* and *server* are both required in shiny app. Ui input can be problematic because some types of input would cause errors in *server* part. For instance, Figure \@ref(fig:p2) was the first-version plan -- the questions provide multiple choices to learners. The advantage of this plan is easy to construct; the disadvantage are the sense of control being reduced and limited choices could limit learners thinking. 

The second version was to let learners enter code freely. This version was similar to [`dwexercise`](https://ebsmonash.shinyapps.io/ecssc2021/#section-what-is-r), but in shiny it was more complicated. If a user wants to enter and run code in basic shiny, there are one options -- `textInput`. But if using `textInput` it would generate two more problems. One way is to let users enter full code of ggplot. The main difficulty here is how to tell the right or wrong of the code. Different coding style and space between variables and arguments can make the comparison be difficult. 

`gradethis`, `vdiffr` and `testthat` are three packages can make the comparison. `gradethis` is a package which is always used with `learnr`. It can compare learners' answers with solutions and gives messages to learners when answers are wrong. However, `gradethis` is compatible with shiny. 

```{r p22, fig.cap="gradethis package", out.width = '100%'}
knitr::include_graphics("screenshot/gradethis.png")
```

Next plan is to use `vdiffr` which is a `testthat` extension for monitoring the appearance of R plots. To use this package, solution plots should be saved, so later they can be used to make the comparison. Using `vdiffr` would make the package too large because of too many SVG files saved in `_snap()` folder. `testthat` is not a good option, either. It is too complicated in shiny.

Learners must enter the code in one line if using `textInput`. This is a problem if the code is too long, such as in Polygon section. The sense of control is also reduced because learners can only know whether their answers are right or wrong. They don't know which part of the answer goes wrong. So, the project will not satisfying the goals of gamification and  cultivating good coding style. Finally, `shinyAce` solved all these problems. `shinyAce` can create a code chunk which is same as the code chunk in **R studio**. It enables users to enter and run code in shiny app. Thus, even the answer is wrong, learners can see the output, which is important because there are two types of wrong answers. One is syntax error, the other is using wrong arguments or wrong variables. This is a big disadvantage when using `textInput`. Only telling students that they are wrong could result in making students remember the right answers. Merely remembering "right answer" is harmful in learning programming. The plan is to make all exercises in the shiny app are fill-in-blanks style, and `shinyAce` is the simple way to fulfill the plan. Another reason of making fill-in-blanks exercises is relatively technical. As mentioned before, different coding style and space between variables and arguments can make the comparison be difficult. The fill-in-blanks questions are easy to make the comparison. 

## Pop-up windows

At first, I never considered about pop-up windows

Then, **Hint** button  not interactive

showModa
modalDialog
use if else function to make two different messages. Success and Wrong. If wrong, contain hint messages

## Making up questions and finding data sets


Who_covid from WHO
GDP from World Bank
Data wrangling 

Questions
Difficulty level,



## Make the shiny app as package









# References




